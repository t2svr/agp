\documentclass[9pt,a4paper,twoside]{article}
\usepackage{geometry}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{svg}

\title{
    Augmented general P systems and high efficiency emulation
    \footnote{
        This work is licensed under CC BY-SA 4.0. To view a copy of this license, visit 
        https://creativecommons.org /licenses/by-sa/4.0/
    }
}

\date{2024-11-11 Draft}
\author{JunShuang Hu\footnote{croteco@outlook.com}}


\begin{document}
    \maketitle
    \pagenumbering{arabic}

\begin{abstract}
    todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo todo 
\end{abstract}
\keywords{Membrane Computing, P Systems, Emulation}

\section{Introduction}

    Based on behaviors of organism in the cell's level, a novel kinds of computing model was formulated. Separation of areas by membranes,
    transportation of matters across membranes and biochemical reactions in membranes are the three important behaviors of cells. 
    These behaviors are captured in symbolic way to crate P systems which transform those behaviors into basic elements for general computing.

    ...  
    todo
    ...  

\section{Purpose of Research}
    Since the very first definition of P system, numerous P systems are defined, some introduced new forms of objects and rules, 
    some designed new representation of membrane. They expanded P system's application ares, enhanced P systems' computing ability.

    Nevertheless, the existing researches mostly focused on improving P systems, rather than the definition of P systems.

    This paper provided an augmented general way of define P systems with object expanding, object subdivision, cross system 
    reusing and rule polymorphism. These methods makes it easier to design and define P systems in a more concise way, especial 
    when abstracting from some complex biological behaviors. 
    
    Design of P systems needs verification, if the designed system is too complex, step-by-step verification manually could be 
    frustrating, hence computer emulation of P system could be helpful in P system design verification. 

    Some P systems are build for current applications. In the help of P system's structural advantage, like other biology inspired 
    systems, P systems implemented on modern silicon based computers could be powerful in certain application areas, thus having a emulation tool
    will reduce the time and energy of implementing these systems. 
    
    The existing emulation tools and libraries are not high efficient or efficient but not general. 
    This paper provided a novel membrane computing library which is efficient and general for implementing the emulator for varies kind of P systems.
   
    
\section{Augmented general P system}

\subsection{Objects}

    Objects definition is in a more refined way in augmented general P system, such consideration is called object subdivision. We use untagged objects in
    situations that rules only care about objects of some types, and use tagged objects when individual objects matters. This is under the inspiration of 
    biochemical reactions of different types.
\subsubsection{Tagged Objects}

        In a augmented general P system tags are used to distinguish different objects of a certain type. 
        A tagged object is defined as $o = (ty, tg)$ where $ty \in S_y, tg \in S_g$ and $S_y, S_g$ are sets of strings on alphabet $A_y, A_g$ separately. 
        $ty$ denotes the type of this object and $tg$ is the tag for this object in its type.
        
        e.g. chromosome $o_1 = (\text{"Human Chromosome"}, 22)$ 
        and $o_2 = (\text{"Human Chromosome"}, 1)$
\paragraph{Uniqueness of tagged objects:}
            
                For two objects $o_1 = (ty_1, tg_1)$ and $o_2 = (ty_2, tg_2)$, we say $o_1$ and $o_2$ are the same object if and only if 
                $ty_1 = ty_2$ and $tg_1 = tg_2$.
\paragraph{Objects of the same type:}
            
                For two objects $o_1 = (ty_1, tg_1)$ and $o_2 = (ty_2, tg_2)$, we say $o_1$ and $o_2$ are of the same type if and only if 
                $ty_1 = ty_2$.
\paragraph{Unique properties of tagged objects:}
            
                Because every tagged objects are different, there could be some unique properties for a certain object that affect how rules could be 
                applied, these properties can be used to simplify the design of rules which abstracted from behaviors like gene expression or protein functioning.
                
                The properties $p$ of object $o$ is defined as $p = Property(o)$, where $Property: O_t \rightarrow P$, $O_t$ is a set of tagged objects,
                $P$ is the power set of the union of sets $S_1, S_2,...,S_n$, $S_1, S_2,...,S_n$ represent different kinds of properties .
                
                e.g. for
                $o_1 = ($"protein"$, 1)$,
                $o_2 = ($"protein"$, 2)$,
                $Property(o_1) = \{$"has glycine"$,$"10 amino acids"$,42\}$,
                $Property(o_2) = \{$"has leucine"$,$"20 amino acids"$,233\}$
                
                This allows to express almost anything related to a certain object further used by rules.
                
\subsubsection{Untagged Objects}
        
            Untagged objects are more like the original definition of objects in previous P systems.
            Untagged objects are described as a type of objects, an untagged object is defined as $u = ty$ where $ty \in S_y$ and $S_y$ is a set of strings on alphabet $A_y$. 
            
            It is useful when designing rules for a type of objects like the rule from proteolysis in which case the differences of each protein are out of concern.
            Untagged objects ignores the difference of objects of the same type. e.g. carbohydrate $u_1 = \text{"Galactose"}$ and $u_2 = \text{"Glucose"} $
\paragraph{Amount of untagged objects:}
                
                    Let $Amount: O_u \rightarrow \mathbb{R}$ be the mapping of the amount of a untagged object from $O_u$.
                    Let $a_{ty} = Amount_\omega(ty)$ be the amount of object of type $ty$ in region $\omega$, where $\omega \in S$ and $Amount_\omega: S_y \rightarrow \mathbb{R}$, 
                    $S$ and $S_y$ are sets of strings. The following equation is always satisfied.
                    \begin{equation}
                        \begin{align}
                            a_{ty} &= Amount_\omega(ty) \\
                            &= \sum_{o \in O'}{Amount(o)} \\
                        \end{align}
                    \end{equation}
                    where $O' = \{ o_i = ty_i \mid o_i \in O_u, o_i\text{ is in region }\omega, ty_i = ty \} $. This is equivalent to the expression with multi-set of 
                    untagged objects in a region, where the multitude of each object is a real number which corresponding to the amount of objects in a region. 

\paragraph{Untagged reference of tagged object}
               
                    Let $Amount_t: O_t \rightarrow \mathbb{R}$ be the amount of a single tagged object in $O_t$, if not defined, $Amount_t(o) = 1$.
                    For tagged objects $o_1, o_2,...,o_n, n \in \mathbb{N}^+$ and $a_i = Amount_t(o_i)$, where $o_i = (ty, tg_i)$ and pair $p_i=(o_i, a_i)_{amount}$ 
                    of mapping $Amount_t$ satisfies $p_i \in Property(o_i)$ for $1 \leq i \leq n$.

                    Let $a = \sum{a_i}$, the untagged reference of $o_1, o_2, ..., o_n$ is $u_r = ty$ with $Amount(u_r) = a$. $o_1, o_2, ..., o_n$ are called
                    the original objects of $u_r$. Note that the original objects of a untagged reference is not unique.

                    Untagged objects are like small molecules while tagged objects are like macromolecules. Conditions with untagged objects usually correspond to the
                    statistical characteristics of small molecules, like concentration, while tagged objects are for reactions in molecule level, like gene expressions.
                    They represent real life objects in different scales, the untagged reference is a bridge between them, allows the same object to be used in different
                    scale. 

                    Note that $Amount_t$ is not the "amount of this tagged object", rather, it is "the amount the untagged object that this tagged object turned into".
                    Due to the uniqueness of tagged objects, "the amount of this tagged object" should always be one across all regions.

\subsection{Rules}

    A rule $r$ is in the form of $r: c \rightarrow e_c$, $c \in C_O$ is called the condition of $r$ and $e_c \in E_c$ is called the effect of $r$ under its
    condition $c$, $C_O$ is a set of conditions on objects $O$ and $E_c$ is a set of effects under condition $c$.

\paragraph{Tagged reference of rule}
    
            For a rule $r: c \rightarrow e_c$ in region $\omega$, it can be seen as a tagged object $o_r = (r, \omega)$ with $(c \rightarrow e_c) \in Property(o_r)$
            or vice versa. $o_r$ is then called the tagged reference of $r$, and $r$ is called the original rule of $o_r$. When there's no confusion, $r$ and $o_r$
            can share a same symbol.

            For clarity of expression, the variable parts of the rule's condition and effect should be written as variables along with the rule definition. Let
            $a_1, a_2,..,a_n$($n \geq 1$) be the variable of rule $r$, $r$ is defined as $r(a_1, a_2,...,a_n): c \rightarrow e_c$.
            Further, $a_i \in Property(o_r), 1 \leq i \leq n$

            Once rules are taken as objects, they can be modified by other rules, or itself, this brings more flexibility to the system. For example in a spiking neural  
            P system with dynamic threshold, each time the fire rule has been applied, the threshold of the fire rule will be changed. Therefore the condition of firing
            rule is not static, but its original definition implicitly used this concept. In augmented general P systems, this mutability must be used explicitly with
            tagged references for a clear and unified expression.

\subsubsection{Conditions}
        
            Let $C_u = \{(u, a) \mid u \in O_u \cup O_{ru}, a \in \mathbb{R}\}$ where $O_u$ is a set of untagged objects and $O_{ru}$ is a set untagged references.
            Let $C_t = O_t \cup O_{rt}$ where $O_t$ is a set of tagged objects and $O_{rt}$ is a set tagged references.
            The set of conditions on $O = O_t \cup O_u$ is $C = \{(c_t, c_u) \mid c_t \subseteq C_t, c_u \subseteq C_u\}$ 
            where $O_t$ is a set of tagged objects and tagged references.

\paragraph{Determined condition and non-determined condition}
            Condition $c=(c_t, c_u)$ is a determined condition if and only if there is no untagged references in
            $c_u$, else it is a non-determined condition.  
            
            A rule with non-determined condition requires the region to have a certain amount of tagged objects of some types, 
            but the exact objects used for this rule is chosen in a non-determined way.
            
            e.g. 
            $c_1 = (\{o_{t1}, o_{t2}\}, \{(u_1, 10.0), (u_2, 5.0)\})$ for tagged objects $o_{t1}, o_{t2}$ and untagged objects $u_1, u_2$,
            or more realistically
            $c = (\{ o_1=($"protein"$,$ $1)$ $,$ $ o_2=($"protein"$,$$ 2) \}$ $,$ $ \{(u_1=$"temperature" $,$
            $40)$ $,$ $ (u_2=$"pH"$,$$ 8.1)\})$.
            
\subsubsection{Effects}
        
            The set of all effect under condition $c=(c_t, c_u)$ is $E_c = \{ f_c \mid f_c: P(O_c) \rightarrow P(I) \}$  where $P(O_c)$ is the power set of 
            $O_c$, $O_c = \{o \mid o \in c_t \vee o \in c_u\}$. $P(I)$ is a power set of influences $I$. 

            Influences describe how a region acts under an effect, for the sack of generality, they are not strictly defined. 
            Depends on the type of the membrane that defines the region, influences may be interpreted differently, this feature is called rule polymorphism. 
            
            Across all membranes, the following types of influences are always recognizable, namely, they are universal influences.
\paragraph{Universal influences:}
          
                A universal influence $i \in I_U$ is defined as $i = (op, (o,a))$, where $op \in \{\text{"Add"}$ $,$ $ \text{"Remove"}, \text{"Stop"}\}$$,$$ o \in O_t \cup O_u \cup \{\epsilon\}$,
                $a \in \mathbb{R} \cup \{\epsilon\}$ is the amount of the object to be removed, $O_t$ is a set of tagged objects, and $O_u$ is a set of untagged objects, 
                $\epsilon$ denotes no object or amount is required. 
                
                If $a = \epsilon$ then $i$ can be written as $i = (op, o)$, if $a = \epsilon$ and $o =\epsilon$,  $i$
                can be written as $i=op$. 
\begin{itemize}
                \item "Add" insists the object $o$ to be added to the region $\omega$ where the rule is applied. 
                    If $a \neq \epsilon$, 
                        when $o$ is tagged, $Amount_t(o) = a$ is added to $Property(o)$, 
                        when $o$ is untagged, $Amount_\omega(o) = a$ is added to region $\omega$. 
                  
                    If $o$ already exists in $\omega$,
                        when $o$ is tagged, the existing object is replaced, for convenience, changes of properties of $o$ can be marked after
                        its symbol as $o(p_1 = p_1', p_2 = p_2',..., p_n = p_n')$
                        when $o$ is untagged, $a_{old} = Amount_\omega(o)$ is replaces by $a_{new} = a_{old} + a$.
                              
                    For untagged object, $a$ can not be $\epsilon$. 

                \item "Remove" insists the object $o$ to be removed in the region where the rule is applied, $o$ must be in the condition of the rule, $a$ is ignored.
                
                \item "Stop" insists the region where the rule is applied to stop evolving, $o$ must be $\epsilon$.
\end{itemize}

            e.g. for rule $r: c \rightarrow e_c$, $c = (\{ o_1=(\text{"protein"}, \text{'a'}) \}, \{(u_1=\text{"enzyme"}, 10)\})$, 
            $e_c = \{ (\{o_1\}, \{(\text{"Remove"}, o_1)\})\} $

            An effect for a rule is a mapping over a subset of objects in the rule's condition to a set of influences.
                
                
\paragraph{Satisfaction of rules and applying rules:}  
           
                For a rule $r: c \rightarrow e_c$ in region $\omega$, $c = (c_t, c_u)$, we call this rule is satisfied in $\omega$ if and only if 
                $\forall o_t \in c_t$ $,$ $ \forall (o_u, a_u) \in c_u$ $,$ $o_t \in O_{\omega}, o_u \in O_{\omega} \text{ and } Amount_\omega(o_u) \geq a_u$.
                
                If rule $r$ is satisfied in region $\omega$, then to apply $r$ in $\omega$ is to calculate the effect mapping $e_c$ to get influences $i$,
                and region $r$ uses $i$ to update itself.
                
                If the condition of a rule is empty, then the rule is always satisfied. If the effect of a rule is empty, then the rule produces no influence.

\subsubsection{Simplified notations}
        
            For rule $r(a_1,a_2,...a_n): c \rightarrow e_c$, where $c=(c_t, c_u)$, the simplified rule expression is:
            \begin{equation}
                \begin{align}
                    &r(a_1,a_2,...a_n): \\
                    &c_1 \rightarrow e_c(c_1)  \\
                    &c_2 \rightarrow e_c(c_2)  \\
                    &...\\
                    &c_n \rightarrow e_c(c_n)  \\
                \end{align}
            \end{equation}
            or in a single line
            \begin{equation}
                r(a_1,a_2,...a_n): c_1c_2...c_n \rightarrow e_c(c_1)e_c(c_2)...e_c(c_n)
            \end{equation}
            where
            \begin{equation}
                \bigcup_{k = 1}^{n}{c_k} = c_t \cup c_u, \bigcap_{k = 1}^{n}{c_k} = \emptyset
            \end{equation}
            
            Then, $c_k = \{o_{k1},o_{k2},...,o_{kp}\} \cup \{(u_{k1},a_{k1}), (u_{k2},a_{k2}),..., (u_{kq},a_{kq})\}$ for $1 \leq k \leq n$ can be written as 
            $o_{k1}o_{k2}...o_{kp}(u_{k1}, a_{k1})(u_{k2}, a_{k2})...(u_{kq}, a_{kq})$.
            
            If $i_k = e_c(c_k)$ are universal influences $\{ (op_1, (o_1,a_1)), (op_2, (o_2,a_2)),...,(op_m, (o_m,a_m))  \}$, 
            $i_k$ can be written as $op_1(o_1, a_1)op_2(o_2, a_2)...op_m(o_m, a_m)$
            
            e.g. 
            \begin{equation}
                \begin{align}
                    &r_1: \\
                    &o_1o_2(u_1, 10) \rightarrow \text{Remove}(o_1)\text{Add}(u_1, 5)  \\
                    &o_3 \rightarrow \text{Add}(o_4) \\
                    &(u_2, 20) \rightarrow \epsilon \\
                \end{align}
            \end{equation}
            or
            \begin{equation}
                \begin{align}
                    &r_2(a): \\
                    &(u_1, a) \rightarrow \text{Remove}(u_1) \\
                    &r_2 \rightarrow \text{Add}(r_2(a = a + 1))
                \end{align}
            \end{equation}
            or
            \begin{equation}
                \begin{align}
                    r_3: o_1o_2(u_1, 60) \rightarrow \text{Add}(o_3)\text{Remove}(o_2)
                \end{align}
            \end{equation}
            or
            \begin{equation}
                \begin{align}
                    r_4:\epsilon \rightarrow \text{Add}(o_1)\text{Add}(u_1, 1.1)
                \end{align}
            \end{equation}

            $\epsilon$ denotes no condition or effect required.
            This allows to implement a very complex behavior in one rule.

\subsection{Membranes}

        In augmented general P systems, a membrane $m$ is defined as $m=(\omega, O_s, R_s, F)$ where $F = (Check^*, Apply^*, Deref_u^*, Deref_t^*, Evolve)$ is the feature tuple of $m$ (or feature for short), $\omega$ is the region defined by $m$, $O_s$ and $R_s$ are objects and rules in $m$.
        Let $O = O_t \cup O_u \cup O_{rt} \cup O_{ru}$ be the set of all possible objects, let $R$ be the set of all possible rules and let $I$ be the set
        of all recognizable influences.
        
        Different types of membranes may have different behaviors or strategies and corresponding to the different feature tuples. Feature tuple decides how a region under a specific membrane should evolve, 
        behaviors of a membrane is abstracted into the following mappings.


    \begin{itemize}
        \item  $Check: (R, P(O)) \rightarrow \{yes, no\}$ is a mapping a rule and a set of objects to a result of $yes$ or $no$, representing the
        the membrane's logic of decide whether a rule can be applied or not on a set of existing objects in a region.
        
        \item  $Apply: (I, P(O)) \rightarrow P(O)$ is a mapping from an influence and a set of objects to a set of updated objects,
        it represents the rule's logic on handling an influence on a set of objects.

        \item $Deref_u: (O_{ru}, \mathbb{R}) \rightarrow P(O_t)$ represents the logic of the membrane on decide the original objects of a untagged reference
        of a certain amount. 
        
        \item $Deref_t: O_{rt} \rightarrow R$, represents the logic of the membrane on decide the original rule of a tagged reference.

        \item $Evolve: (P(O), P(R)) \rightarrow (P(O), P(R))$ defines how this membrane is evolving in each iteration.

    \end{itemize}

        For a feature tuple, only $Evolve$ mapping is required, other mappings are optional and marked with "$*$".
        When processing influences, the following two actions can be done automatically.
        
    \begin{itemize}
        \item Before the effect calculation, if an object is a untagged reference, it will be mapped into tagged objects with $Deref_u$ with the same amount.
        \item After $Apply$ mapping, if an object is a tagged reference, it will be mapped into a rule with $Deref_t$, and the corresponding rule is added or removed. 
    \end{itemize}

\subsubsection{Default scheme of $Evolve$}
        Mapping $Evolve$ can be defined in any form depending on the requirement of the specific system. Default scheme of $Evolve$ gives an optional default infrastructure for systems that build upon augmented general P system, as showing in table 1.
\begin{table}[ht]
\centering
\begin{tabular}{ll}
\hline
Step & Actions           \\ \hline
1    & aaaaaaaaaaaaaaaaaaaaaa \\
     & aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\
2    & aaaaaaaaaaaaaa    \\
3    & aaaaaaaaaaaaa     \\ \hline
\end{tabular}
\caption{Default $Evolve$ mapping }
\label{tab:my-table}
\end{table}

\subsubsection{Region notations}
    A region $\omega$ defined by membrane $m=(\omega, O_s, R_s, F)$ can be written as the 
    following string representation if needed.
    \begin{equation}
        \omega: [ o_1o_2...o_n \mid r_1r_2...r_m ]_F
    \end{equation}
    where $O_s = \{ o_1, o_2,...,o_n \}$ and $R_s = \{r_1,r_2,...,r_m\}$, "$[$ $]_F$" represents the membrane that defines this region with feature $F$. Or with graph representation in figure 1.
    \begin{figure}[ht]
        \centering
        \includesvg{./figures/placeholder.svg}
        \caption{Graph representation of a region}
        \label{fig:enter-label}
    \end{figure}
    

    
\subsection{Cross system reusing}
        

\section{High efficiency emulation for augmented general P system}


\section{Other elements}

        
%----------------------------------------------------------

\printbibliography

%----------------------------------------------------------

\end{document}
